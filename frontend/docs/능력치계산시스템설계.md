# 능력치 계산 시스템 설계서

## 1. 개요

### 1.1 문제 정의
현재 시스템에서는 각 소스(장비, 타이틀, 대바니온, 기본 스탯)의 능력치를 단순 합산하여 표시하고 있으나, 실제 게임 내 최종 능력치와 차이가 발생합니다.

**예시:**
- 전투 속도: 사이트 표시 37.9% vs 게임 내 38.4% (차이: 0.5%)
- 생명력, 공격력 등 다른 스탯에서도 유사한 차이 발생 예상

### 1.2 원인 분석
AION2의 능력치는 다음과 같은 복잡한 계산 과정을 거칩니다:
1. **기본값 (Base)**: 장비 + 타이틀 + 대바니온의 고정 수치 합산
2. **증가율 (Multiplier)**: 기본 스탯, 신 스탯, 타이틀, 대바니온의 % 보너스 적용
3. **최종값 (Final)**: `Base × (1 + Multiplier)`

현재는 고정값과 %값을 별도로 합산만 하고 있어, 실제 게임 내 계산식과 차이가 발생합니다.

---

## 2. 능력치 계산 공식

### 2.1 기본 계산식

```
최종 능력치 = 기본값 × (1 + 증가율)
```

**상세:**
```
기본값 (Base) = 장비 + 타이틀(고정) + 대바니온(고정)
증가율 (Multiplier) = Σ(기본스탯 % + 신스탯 % + 타이틀 % + 대바니온 %)
최종값 (Final) = Base × (1 + Multiplier / 100)
```

### 2.2 스탯별 계산 방식

#### 2.2.1 기본 전투 스탯
- **생명력**, **정신력**, **공격력**, **방어력** 등

```typescript
// 예: 전투 속도
const 기본값 = 0  // 장비/타이틀/대바니온 고정값 (전투속도는 고정값 없음)
const 증가율 =
  시간[시엘] 신스탯(96) × 0.2 +  // 19.2%
  대바니온_네자칸 +                 // 5%
  기타 보너스                       // 추가 %

const 최종값 = Math.floor(기본값 × (1 + 증가율 / 100))
```

#### 2.2.2 파생 스탯
일부 스탯은 다른 스탯으로부터 파생됩니다:

```typescript
// 예: 생명력
const 장비생명력 = 3292  // 장비 합산
const 타이틀생명력 = 800  // 타이틀 고정값
const 대바니온생명력 = 3700  // 대바니온 합산

const 기본생명력 = 장비생명력 + 타이틀생명력 + 대바니온생명력

const 생명력증가율 =
  체력(50) × 0.1 +           // 5%
  생명[유스티엘](53) × 0.2 + // 10.6%
  기타 보너스

const 최종생명력 = Math.floor(기본생명력 × (1 + 생명력증가율 / 100))
```

#### 2.2.3 신 스탯 보너스
신 스탯 포인트는 특정 비율로 능력치를 증가시킵니다:

| 신 | 1차 효과 | 2차 효과 | 변환 비율 |
|---|---|---|---|
| 정의[네자칸] | 방어력 증가 | 완벽 | 0.2% per point |
| 자유[바이젤] | 명중 증가 | 회피 증가 | 0.2% per point |
| 환상[카이시넬] | 재사용 시간 감소 | 철벽 관통 | 0.2% per point |
| 생명[유스티엘] | 생명력 증가 | 재생 | 0.2% per point |
| 시간[시엘] | 전투 속도 | 강타 저항 | 0.2% per point |
| 파괴[지켈] | 공격력 증가 | 완벽 저항 | 0.2% per point |
| 죽음[트리니엘] | 치명타 증가 | 재생 관통 | 0.2% per point |
| 지혜[루미엘] | 정신력 소모량 감소 | 강타 | 0.2% per point |
| 운명[마르쿠탄] | 정신력 증가 | 철벽 | 0.2% per point |
| 공간[이스라펠] | 이동 속도 | 막기 증가 | 0.2% per point |

---

## 3. 시스템 설계

### 3.1 데이터 구조

```typescript
interface StatCalculation {
  name: string              // 스탯 이름
  baseValue: number        // 기본값 (고정 수치 합산)
  multipliers: {           // 증가율 소스별 분류
    baseStats: number      // 기본 스탯 (위력, 민첩, 체력 등)
    godStats: number       // 신 스탯 포인트 보너스
    equipment: number      // 장비 % 보너스
    titles: number         // 타이틀 % 보너스
    daevanion: number      // 대바니온 % 보너스
  }
  totalMultiplier: number  // 총 증가율 (%)
  finalValue: number       // 최종 계산값
  displayValue: string     // 표시용 문자열
}
```

### 3.2 계산 파이프라인

```typescript
// 1단계: 기본값 계산
function calculateBaseValue(stat: StatDetail): number {
  return stat.sources.equipment.reduce((sum, s) => sum + s.value, 0)
    + stat.sources.titles.reduce((sum, s) => sum + s.value, 0)
    + stat.sources.daevanion.reduce((sum, s) => sum + s.value, 0)
}

// 2단계: 증가율 계산
function calculateMultipliers(stat: StatDetail): MultiplierBreakdown {
  return {
    baseStats: calculateBaseStatMultiplier(stat),
    godStats: calculateGodStatMultiplier(stat),
    equipment: stat.sources.equipment.reduce((sum, s) => sum + s.percentage, 0),
    titles: stat.sources.titles.reduce((sum, s) => sum + s.percentage, 0),
    daevanion: stat.sources.daevanion.reduce((sum, s) => sum + s.percentage, 0)
  }
}

// 3단계: 최종값 계산
function calculateFinalValue(base: number, multiplier: number): number {
  return Math.floor(base * (1 + multiplier / 100))
}
```

### 3.3 특수 계산 규칙

#### 3.3.1 소수점 처리
```typescript
// 게임 내부적으로는 소수점까지 계산하지만 표시는 버림
const finalValue = Math.floor(baseValue * (1 + totalMultiplier / 100))
```

#### 3.3.2 상한/하한 적용
일부 스탯은 최소/최대값이 있을 수 있음:
```typescript
const clampedValue = Math.max(minValue, Math.min(maxValue, calculatedValue))
```

#### 3.3.3 스탯 간 상호작용
- 일부 스탯은 다른 스탯의 영향을 받음
- 예: 치명타 피해는 치명타 확률에 영향을 받음

---

## 4. 구현 계획

### 4.1 Phase 1: 계산 엔진 구축
**목표**: 기본 계산 로직 구현

**파일 생성**:
- `frontend/src/lib/statCalculator.ts`: 계산 로직
- `frontend/src/types/statCalculation.ts`: 타입 정의

**구현 내용**:
```typescript
// statCalculator.ts
export function calculateFinalStats(
  equipment: any[],
  titles: any,
  daevanion: any,
  stats: any,
  equippedTitleId?: number
): StatCalculation[] {
  // 1. 기존 aggregateStats로 원본 데이터 수집
  const rawStats = aggregateStats(equipment, titles, daevanion, stats, equippedTitleId)

  // 2. 각 스탯별 계산 수행
  return rawStats.map(stat => calculateStat(stat, stats))
}

function calculateStat(stat: StatDetail, gameStats: any): StatCalculation {
  const base = calculateBaseValue(stat)
  const multipliers = calculateMultipliers(stat, gameStats)
  const totalMultiplier = Object.values(multipliers).reduce((sum, m) => sum + m, 0)
  const final = calculateFinalValue(base, totalMultiplier)

  return {
    name: stat.name,
    baseValue: base,
    multipliers,
    totalMultiplier,
    finalValue: final,
    displayValue: formatStatValue(stat.name, final, totalMultiplier)
  }
}
```

### 4.2 Phase 2: 신 스탯 매핑
**목표**: 신 스탯 포인트 → 능력치 변환

**구현**:
```typescript
// godStatMapping.ts
export const GOD_STAT_EFFECTS: Record<string, GodStatEffect> = {
  '정의[네자칸]': {
    primary: { stat: '방어력 증가', ratio: 0.2 },
    secondary: { stat: '완벽', ratio: 0.2 }
  },
  '시간[시엘]': {
    primary: { stat: '전투 속도', ratio: 0.2 },
    secondary: { stat: '강타 저항', ratio: 0.2 }
  },
  // ... 나머지 신 스탯
}

export function applyGodStatBonus(
  statName: string,
  godStats: GodStatPoint[]
): number {
  let totalBonus = 0

  for (const godStat of godStats) {
    const effect = GOD_STAT_EFFECTS[godStat.name]
    if (!effect) continue

    if (effect.primary.stat === statName) {
      totalBonus += godStat.value * effect.primary.ratio
    }
    if (effect.secondary.stat === statName) {
      totalBonus += godStat.value * effect.secondary.ratio
    }
  }

  return totalBonus
}
```

### 4.3 Phase 3: UI 업데이트
**목표**: 계산된 최종값을 사용자에게 표시

**수정 파일**:
- `StatsSummaryView.tsx`: 계산된 값 표시
- `StatTooltip.tsx`: 계산 과정 상세 표시

**UI 개선안**:
```typescript
// 툴팁에 계산 과정 표시
<div>
  <div>기본값: {calculation.baseValue.toLocaleString()}</div>
  <div>증가율:
    <div>- 기본 스탯: +{calculation.multipliers.baseStats}%</div>
    <div>- 신 스탯: +{calculation.multipliers.godStats}%</div>
    <div>- 장비: +{calculation.multipliers.equipment}%</div>
    <div>- 타이틀: +{calculation.multipliers.titles}%</div>
    <div>- 대바니온: +{calculation.multipliers.daevanion}%</div>
  </div>
  <div>총 증가율: +{calculation.totalMultiplier}%</div>
  <div>최종값: {calculation.finalValue.toLocaleString()}</div>
</div>
```

### 4.4 Phase 4: 검증 및 테스트
**목표**: 게임 내 값과 비교하여 정확도 검증

**테스트 케이스**:
1. 전투 속도: 37.9% → 38.4% 일치 확인
2. 생명력: 현재값 → 게임 내 값 일치 확인
3. 공격력, 방어력 등 주요 스탯 검증

**디버깅 모드**:
```typescript
// 개발자 모드에서 계산 과정 출력
if (process.env.NODE_ENV === 'development') {
  console.log('[Stat Calculator Debug]', {
    statName: calculation.name,
    base: calculation.baseValue,
    multipliers: calculation.multipliers,
    final: calculation.finalValue
  })
}
```

---

## 5. 예상 이슈 및 해결 방안

### 5.1 반올림/버림 규칙
**이슈**: 게임 내부 계산 방식 불명확
**해결**:
- 기본은 `Math.floor` (버림) 사용
- 검증 후 필요시 `Math.round` (반올림) 또는 `Math.ceil` (올림)로 변경

### 5.2 스탯 간 의존성
**이슈**: 일부 스탯은 다른 스탯의 영향을 받음
**해결**:
- 계산 순서 정의 (독립적 스탯 → 파생 스탯)
- 순환 참조 방지 로직 추가

### 5.3 숨겨진 보너스
**이슈**: API에 노출되지 않는 숨겨진 보너스 존재 가능
**해결**:
- 게임 내 값과 차이 발생 시 보정 계수(correction factor) 추가
- 사용자 피드백 수집하여 지속적 개선

### 5.4 패치에 따른 공식 변경
**이슈**: 게임 업데이트로 계산식 변경 가능
**해결**:
- 계산 공식을 별도 설정 파일로 관리
- 버전별 공식 관리 시스템 구축

---

## 6. 성능 고려사항

### 6.1 캐싱 전략
```typescript
// 메모이제이션으로 재계산 방지
const memoizedCalculation = useMemo(
  () => calculateFinalStats(equipment, titles, daevanion, stats, equippedTitleId),
  [equipment, titles, daevanion, stats, equippedTitleId]
)
```

### 6.2 점진적 계산
- 사용자가 보는 탭의 스탯만 우선 계산
- 나머지는 백그라운드에서 lazy 계산

---

## 7. 향후 확장 가능성

### 7.1 시뮬레이터 기능
사용자가 장비/스탯을 변경했을 때 최종 능력치 변화를 실시간으로 시뮬레이션

### 7.2 최적화 추천
특정 목표 능력치를 달성하기 위한 최적의 스탯 배분 추천

### 7.3 비교 기능
다른 캐릭터 또는 빌드와 능력치 비교

---

## 8. 참고 자료

### 8.1 현재 구현 파일
- `frontend/src/lib/statsAggregator.ts`: 현재 단순 합산 로직
- `frontend/src/types/stats.ts`: 스탯 타입 정의
- `frontend/src/app/components/StatsSummaryView.tsx`: UI 컴포넌트

### 8.2 API 데이터 구조
- `stat.statList`: 기본 스탯 + 신 스탯
- `stat.statSecondList`: 2차 파생 능력치 (이미 % 계산된 값)
- `equipment.detail.options`: 장비 기본 옵션
- `equipment.detail.randomOptions`: 장비 랜덤 옵션
- `titles.statList`: 타이틀 보유 효과
- `titles.equipStatList`: 타이틀 장착 효과
- `daevanion.boardList`: 대바니온 보드별 노드 수

---

## 9. 구현 우선순위

### 우선순위 1 (긴급)
- [ ] 전투 속도 계산식 정확도 개선
- [ ] 생명력 계산식 구현

### 우선순위 2 (중요)
- [ ] 공격력, 방어력 계산식 구현
- [ ] 치명타 관련 스탯 계산식 구현

### 우선순위 3 (보통)
- [ ] 나머지 모든 스탯 계산식 구현
- [ ] 툴팁 UI 개선

### 우선순위 4 (낮음)
- [ ] 시뮬레이터 기능
- [ ] 최적화 추천 기능

---

## 10. 결론

능력치 계산 시스템은 단순 합산에서 벗어나 게임 내부 로직을 모방하여 정확한 최종 능력치를 계산하는 것을 목표로 합니다. 이를 통해 사용자에게 더 정확하고 신뢰할 수 있는 정보를 제공할 수 있습니다.

**핵심 공식**:
```
최종 능력치 = 기본값 × (1 + 총증가율/100)
```

이 공식을 바탕으로 각 스탯별 특성을 고려한 세부 계산 로직을 구현하면, 게임 내 표시값과 거의 일치하는 결과를 얻을 수 있을 것으로 예상됩니다.
